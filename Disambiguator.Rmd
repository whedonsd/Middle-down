---
title: "Disambiguator"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook.

Libraries, mass definitions, ion functions

```{r}
directory <- c("C:/TPP/data/test")
setwd(directory)

library(parallel)
library(purrr)
library(Spectra)
library(mzR)
library(tidyr)
library(stringr)
library(dplyr)
library(xml2)
library(readr)
library(writexl)

# Monoisotopic masses of amino acids
amino_acid_masses <- c(
  A = 71.03711, R = 156.10111, N = 114.04293, D = 115.02694,
  C = 103.00919, E = 129.04259, Q = 128.05858, G = 57.02146,
  H = 137.05891, I = 113.08406, L = 113.08406, K = 128.09496,
  M = 131.04049, F = 147.06841, P = 97.05276, S = 87.03203,
  T = 101.04768, W = 186.07931, Y = 163.06333, V = 99.06841
)

# Atomic masses for elements (Monoisotopic)
atomic_masses <- c(
  C = 12.0, c = 13.0033548378, H = 1.007825, h = 1.007276, N = 14.003074, n = 15.0001088982, O = 15.994915, P = 30.973762, S = 31.972071
)

# Adjustments for ion types
ion_type_adjustments <- list(
  b = 0, # [N]+[M]-H  ; N = mass of neutral N terminal group
  y = atomic_masses["H"], # c-term TMT modificationa already takes -OH into account # atomic_masses["H"] * (2) + atomic_masses["O"], # Neutral mass = [C]+[M]+H ; C = mass of neutral C-terminal group (OH)
  c = atomic_masses["H"] + (atomic_masses["H"] * (2) + atomic_masses["N"]), # [N]+[M]+NH2  ; N = mass of neutral N terminal group
  z = (atomic_masses["O"] - atomic_masses["N"]) - (atomic_masses["H"] * 1 + atomic_masses["O"]), # c-term TMT modificationa already takes -OH into account  # atomic_masses["O"] - atomic_masses["N"] # Neutral mass = [C]+[M]-NH2 ; C = mass of neutral C-terminal group (OH)
	# We're really printing Z-dot ions so we add an H to make it OH+[M]-NH2 +H = [M]+O-N
  Ion_AmmoniaLossMass = atomic_masses["H"] * 3 + atomic_masses["N"], # Define neutral loss masses
  Ion_WaterLossMass = atomic_masses["H"] * 2 + atomic_masses["O"] # Define neutral loss masses
)

# Function to calculate m/z for ions
calculate_ion_mz <- function(peptide_mass, charge) {
  # Adjust mass for ion type and add protons for charge
  mz <- (peptide_mass + atomic_masses["h"] * charge) / charge # h is proton
  return(mz)
}

calculate_fragment_mass_from_sequence <- function(sequence, modifications = NULL) {
  mass <- sum(sapply(strsplit(sequence, "")[[1]], function(aa) {
    if (aa %in% names(amino_acid_masses)) {
      return(amino_acid_masses[[aa]])
    } else {
      stop(paste("Undefined amino acid or modification:", aa))
    }
  }))
  
  if (!is.null(modifications) && nrow(modifications) > 0) {
    for (i in 1:nrow(modifications)) {
      mod <- modifications[i, ]
      if (mod$position <= nchar(sequence)) {
        mass <- mass + as.numeric(mod$variable)  # Ensure mass is treated as numeric
      }
    }
  }
  
  return(mass)
}

generate_ions_for_sequence <- function(sequence, modifications_df) {
  ions_list <- list()
  sequence_length <- nchar(sequence)
  
  for (charge in 1:6) {
    b_ions <- numeric(sequence_length - 1)
    b_nl_O_ions <- numeric(sequence_length - 1)
    b_nl_N_ions <- numeric(sequence_length - 1)
    y_ions <- numeric(sequence_length - 1)
    y_nl_O_ions <- numeric(sequence_length - 1)
    y_nl_N_ions <- numeric(sequence_length - 1)
    c_ions <- numeric(sequence_length - 1)
    c_nl_O_ions <- numeric(sequence_length - 1)
    c_nl_N_ions <- numeric(sequence_length - 1)
    z_ions <- numeric(sequence_length - 1)
    z_nl_O_ions <- numeric(sequence_length - 1)
    z_nl_N_ions <- numeric(sequence_length - 1)
    
    for (i in 1:(sequence_length - 1)) {
      b_seq <- substr(sequence, 1, i)
      y_seq <- substr(sequence, sequence_length - i + 1, sequence_length)
      c_seq <- substr(sequence, 1, i)
      z_seq <- substr(sequence, sequence_length - i + 1, sequence_length)
      
      # For b ions, use positions directly as they are from N-terminus
      b_mods <- modifications_df[modifications_df$position <= i,]
      c_mods <- modifications_df[modifications_df$position <= i,]
      
      # For y ions, adjust positions relative to the fragment's C-terminus
      y_mods <- modifications_df
      if (nrow(y_mods) > 0) {
        y_mods$position <- sequence_length - y_mods$position + 1
        y_mods <- y_mods[y_mods$position <= i,]
      }
      z_mods <- modifications_df
      if (nrow(z_mods) > 0) {
        z_mods$position <- sequence_length - z_mods$position + 1
        z_mods <- z_mods[z_mods$position <= i,]
      }

      # Calculate the mass of the b and y ion sequences
      b_mass <- calculate_fragment_mass_from_sequence(b_seq, b_mods) + ion_type_adjustments$b
      y_mass <- calculate_fragment_mass_from_sequence(y_seq, y_mods) + ion_type_adjustments$y
      c_mass <- calculate_fragment_mass_from_sequence(c_seq, c_mods) + ion_type_adjustments$c
      z_mass <- calculate_fragment_mass_from_sequence(z_seq, z_mods) + ion_type_adjustments$z
      
      # Check for potential neutral losses and calculate accordingly
      if (grepl("[KRQN]", b_seq)) {
        b_mass_N_loss <- b_mass - ion_type_adjustments$Ion_AmmoniaLossMass
        b_nl_N_ions[i] <- calculate_ion_mz(b_mass_N_loss, charge)
      }
      if (grepl("[STED]", b_seq)) {
        b_mass_O_loss <- b_mass - ion_type_adjustments$Ion_WaterLossMass
        b_nl_O_ions[i] <- calculate_ion_mz(b_mass_O_loss, charge)
      }
      # Check for potential neutral losses and calculate accordingly
      if (grepl("[KRQN]", y_seq)) {
        y_mass_N_loss <- y_mass - ion_type_adjustments$Ion_AmmoniaLossMass
        y_nl_N_ions[i] <- calculate_ion_mz(y_mass_N_loss, charge)
      }
      if (grepl("[STED]", y_seq)) {
        y_mass_O_loss <- y_mass - ion_type_adjustments$Ion_WaterLossMass
        y_nl_O_ions[i] <- calculate_ion_mz(y_mass_O_loss, charge)
      }
      # Check for potential neutral losses and calculate accordingly
      if (grepl("[KRQN]", c_seq)) {
        c_mass_N_loss <- c_mass - ion_type_adjustments$Ion_AmmoniaLossMass
        c_nl_N_ions[i] <- calculate_ion_mz(c_mass_N_loss, charge)
      }
      if (grepl("[STED]", c_seq)) {
        c_mass_O_loss <- c_mass - ion_type_adjustments$Ion_WaterLossMass
        c_nl_O_ions[i] <- calculate_ion_mz(c_mass_O_loss, charge)
      }
      # Check for potential neutral losses and calculate accordingly
      if (grepl("[KRQN]", z_seq)) {
        z_mass_N_loss <- z_mass - ion_type_adjustments$Ion_AmmoniaLossMass
        z_nl_N_ions[i] <- calculate_ion_mz(z_mass_N_loss, charge)
      }
      if (grepl("[STED]", z_seq)) {
        z_mass_O_loss <- z_mass - ion_type_adjustments$Ion_WaterLossMass
        z_nl_O_ions[i] <- calculate_ion_mz(z_mass_O_loss, charge)
      }
      
      b_ions[i] <- calculate_ion_mz(b_mass, charge)
      y_ions[i] <- calculate_ion_mz(y_mass, charge)
      c_ions[i] <- calculate_ion_mz(c_mass, charge)
      z_ions[i] <- calculate_ion_mz(z_mass, charge)
    }
    
    ions_list[[paste("b_ions_charge", charge)]] <- b_ions
    ions_list[[paste("b_nl_O_ions_charge", charge)]] <- b_nl_O_ions
    ions_list[[paste("b_nl_N_ions_charge", charge)]] <- b_nl_N_ions
    ions_list[[paste("y_ions_charge", charge)]] <- y_ions
    ions_list[[paste("y_nl_O_ions_charge", charge)]] <- y_nl_O_ions
    ions_list[[paste("y_nl_N_ions_charge", charge)]] <- y_nl_N_ions
    ions_list[[paste("c_ions_charge", charge)]] <- c_ions
    ions_list[[paste("c_nl_O_ions_charge", charge)]] <- c_nl_O_ions
    ions_list[[paste("c_nl_N_ions_charge", charge)]] <- c_nl_N_ions
    ions_list[[paste("z_ions_charge", charge)]] <- z_ions
    ions_list[[paste("z_nl_O_ions_charge", charge)]] <- z_nl_O_ions
    ions_list[[paste("z_nl_N_ions_charge", charge)]] <- z_nl_N_ions
  }
  
  return(ions_list)
}

```

Reading in pep.xml data and formatting for search

```{r}
setwd(directory)
my_pep_xml <- c("20240215_EBZ_Cole_20ng_293f_MS275vDMSO_1to1_6plex_2-15grad.pep.xml")

# Load your XML data
peptide_data <- read_xml(my_pep_xml)

# Assuming 'peptide_data' is your XML document
# Rename namespaces for easier handling
ns <- xml_ns_rename(xml_ns(peptide_data), c(d1 = "d1"))

# Find all <spectrum_query> nodes, including the namespace prefix in the XPath
spectrum_queries <- xml_find_all(peptide_data, "//d1:spectrum_query", ns)
```

Go to the Trans-Proteomic Pipeline
Use Percolator to process your tab delimited .txt file
Use flags -Y -U -D 15 -V -docdMdRT -O
This takes a few minutes depending on your hardware
Read in the result 'pin.tsv' file below

```{r}
# set working directory
setwd(directory)

# Read the Percolator output into a data.frame
PSM_df <- read_tsv("C:/TPP/data/293f_2to15_DMSO_MS275_1to1_6plex/20240215_EBZ_Cole_20ng_293f_MS275vDMSO_1to1_6plex_2-15grad_R-reclassified_pin.tsv")

# Extract scan numbers, charge state information from the PSMId column into new columns
PSM_df <- PSM_df %>%
  extract(PSMId, into = c("scan_number", "charge", "hit_rank"),
          regex = ".*_(\\d+)_(\\d+)_(\\d+)$",
          remove = FALSE) %>%
  mutate(across(c(scan_number, charge, hit_rank), as.integer))

# Filter out peptides with PEP values =<0.05
PSM_df <- PSM_df %>% 
  filter(posterior_error_prob <= 0.05)
  
# Extract the scan number column as a vector for filtering the pep.xml file read in at the beginning of the notebook
PSM_scan_number <- unique(PSM_df$scan_number)

# Assuming peptide_data and ns are already defined
spectrum_queries <- xml_find_all(peptide_data, "//d1:spectrum_query", ns)

# Iterate through each spectrum_query
for (spectrum_query in spectrum_queries) {
  start_scan_value <- xml_attr(spectrum_query, "start_scan")
  
  # Convert start_scan_value to integer for accurate comparison
  start_scan_value <- as.integer(start_scan_value)
  
  # Check if this spectrum_query's start_scan_value is in the PSM_scan_number list
  if (!(start_scan_value %in% PSM_scan_number)) {
    # If not, remove this spectrum_query
    xml_remove(spectrum_query)
  }
}
```



```{r}
# Cut down the current list of spectrum queries so we don't have to hold every value in memory
# Find all <spectrum_query> nodes, including the namespace prefix in the XPath
spectrum_queries <- xml_find_all(peptide_data, "//d1:spectrum_query", ns)

# Initialize an empty list to store modifications data
modifications_data <- list()

# Iterate through each spectrum query to process search hits individually
for (i in seq_along(spectrum_queries)) {
  spectrum_query <- spectrum_queries[i]
  
  # Extract 'start_scan' attribute
  start_scan <- xml_attr(spectrum_query, "start_scan")
  
  # Find <search_hit> nodes within the current <spectrum_query>, including the namespace prefix
  search_hits <- xml_find_all(spectrum_query, ".//d1:search_hit", ns)
  
  # Initialize an empty list for this spectrum_query to store data by hit_rank
  hit_data_list <- list()
  
  # Iterate through each search hit
  for(hit in search_hits) {
    # Extract 'hit_rank' and 'peptide' attributes
    hit_rank <- xml_attr(hit, "hit_rank")
    peptide <- xml_attr(hit, "peptide")
      
    # Find <modification_info> node for the current hit, including the namespace prefix
    modification_info <- xml_find_first(hit, ".//d1:modification_info", ns)
  
    # Initialize an empty dataframe for modifications for this hit
    modifications_df <- data.frame(position = integer(), variable = numeric(), stringsAsFactors = FALSE)
  
    # Process <mod_aminoacid_mass> modifications
    mod_aminoacid_masses <- xml_find_all(modification_info, ".//d1:mod_aminoacid_mass", ns)
    for(mod_info in mod_aminoacid_masses) {
      position <- as.integer(xml_attr(mod_info, "position")) # Corrected variable name here
      variable <- as.numeric(xml_attr(mod_info, "variable")) # Corrected attribute "variable" describes the mass added to the modified amino acid
  
      # Append to the dataframe
      modifications_df <- rbind(modifications_df, data.frame(position, variable))
    }

  
    # Check for and process 'mod_cterm_mass' if it exists
    mod_cterm_mass <- xml_attr(modification_info, "mod_cterm_mass")
    if (!is.na(mod_cterm_mass) && mod_cterm_mass != "") {
      cterm_position <- nchar(peptide)  # Position is the length of the peptide
      cterm_variable <- as.numeric(mod_cterm_mass)
    
      # Append to the dataframe
      modifications_df <- rbind(modifications_df, data.frame(position = cterm_position, variable = cterm_variable))
    }
  
    # Combine peptide and modifications into a single structure
    hit_data <- list(peptide = peptide, modifications = modifications_df)
  
    # Store this combined data in the hit_data_list with 'hit_rank' as the key
    hit_data_list[[hit_rank]] <- hit_data
  }

  # Store the list of combined peptide and modifications data by hit_rank for this spectrum_query, indexed by 'start_scan'
  modifications_data[[start_scan]] <- hit_data_list
}

# 'modifications_data' now contains both peptide sequences and modifications for each search hit, segregated by 'hit_rank', for each spectrum query
```


Reading in .raw data

```{r}
setwd(directory)

mz <- openMSfile("20240215_EBZ_Cole_20ng_293f_MS275vDMSO_1to1_6plex_2-15grad.mzML.gz")
p <- peaks(mz) ## extract all peak information
```

Matching calculated ions to spectrum ions

```{r}
# Define fn to calculate tolerance
calculate_tolerance <- function(mz, ppm) {
  return(as.numeric(mz) * ppm / 1e6)
}

find_matches_with_intensity_df <- function(ions_df, scan_data, ppm_tolerance, sequence) {
  matches <- list()
  sequence_length <- nchar(sequence)
  
  # Identify ion type columns in the dataframe
  ion_columns <- names(ions_df)
  
  for (ion_column in ion_columns) {
    # Determine the charge state based on the column name
    charge_state <- as.numeric(gsub(".*charge[ .](\\d+)$", "\\1", ion_column))
    ion_vector <- ions_df[[ion_column]]
    
    for (i in seq_along(ion_vector)) {
      ion_mass <- ion_vector[i]
      ion_tolerance <- calculate_tolerance(ion_mass, ppm_tolerance)
      
      # Find indices of matching m/z values within tolerance
      matching_indices <- which(abs(scan_data[, "mz"] - ion_mass) <= ion_tolerance)
      
      if (length(matching_indices) > 0) {
        for (match_index in matching_indices) {
          # Skip condition for +1 charge state ions if their position is greater than half the sequence length
          if (charge_state == 1 && i < sequence_length / 2) {
            next
          }
          # Insert additional "else if" conditions here for specific charge states
          # Additional conditions for other charge states if needed
          # Example for +3 charge state (you can add logic inside the block)
          else if (charge_state == 3 && i < sequence_length / 3) {
            # Specific logic for +3 charge state ions
          }
          
          # Condition for +4 charge state ions
          else if (charge_state == 4 && i < 3) {
            # Apply specific logic for +2 charge state ions
            # You can add more specific conditions for +2 charge state ions here
          }
          
          # Condition for +5 charge state ions
          else if (charge_state == 5 && i < 4) {
            # Apply specific logic for +2 charge state ions
            # You can add more specific conditions for +2 charge state ions here
          }
          
          # Condition for +5 charge state ions
          else if (charge_state == 6 && i < 4) {
            # Apply specific logic for +2 charge state ions
            # You can add more specific conditions for +2 charge state ions here
          }
          # Calculate expected m/z for isotopic peak
          expected_isotopic_mz <- scan_data[match_index, "mz"] + (1 / charge_state)
          isotopic_tolerance <- calculate_tolerance(expected_isotopic_mz, ppm_tolerance)
          
          # Find isotopic peak within tolerance
          isotopic_peak_indices <- which(abs(scan_data[, "mz"] - expected_isotopic_mz) <= isotopic_tolerance)
          
          if (scan_data[match_index, "intensity"] > 1500) {
            # Filter isotopic peaks by intensity condition (<90% of the match intensity) for match intensity > 1500
            valid_isotopic_peaks <- isotopic_peak_indices[scan_data[isotopic_peak_indices, "intensity"] < 0.9 * scan_data[match_index, "intensity"]]
          } else {
            # For match intensity <= 1500, consider all isotopic peaks as valid without applying the <90% intensity condition
            valid_isotopic_peaks <- isotopic_peak_indices
          }
          
          if (length(valid_isotopic_peaks) > 0) {
            # Construct a key for this match, including the column name and ion position
            match_key <- paste(ion_column, "pos", i, "mz", round(ion_mass, 4), "charge", charge_state, sep = "_")
            # Store match with its intensity and isotopic peak info
            matches[[match_key]] <- list(mz = scan_data[match_index, "mz"], intensity = scan_data[match_index, "intensity"], isotopic_peaks = list(mz = scan_data[valid_isotopic_peaks, "mz"], intensity = scan_data[valid_isotopic_peaks, "intensity"]))
          }
        }
      }
    }
  }
  
  return(matches)
}

# Key Points:
# Charge State Detection: The function now includes logic to determine the charge state from the column name. This uses a regular expression with gsub() to extract the charge state number from the column name pattern like "y_ions_charge.1". Adjust the pattern as necessary to match your dataframe's column naming convention.

# Biochemical Rule Application: Before proceeding with the match finding for each ion, it checks if the ion is in the +1 charge state and if its position is greater than half the length of the sequence. If both conditions are met, the next statement skips the rest of the current iteration, effectively filtering out these ions from the match list.

# Sequence Length Consideration: The function now requires the sequence parameter to calculate the sequence length and thereby apply the biochemical rule accurately.

# This approach allows you to integrate specific biochemical rules into the process of identifying and retaining meaningful matches, enhancing the biological relevance of your analysis results.
```

Initializing containers (was testing)

```{r}

# I think these basically initialize the containers
scan2012 <- peaks(mz, scan=2012)
scan2012 <- as.data.frame(scan2012)
scan_2012_hit_1_data <- modifications_data[["2012"]][["1"]]
peptide_sequence <- scan_2012_hit_1_data$peptide
modifications_df <- scan_2012_hit_1_data$modifications
print(scan_2012_hit_1_data)
# Now you can use peptide_sequence and modifications_df for your calculations

ions_df <- as.data.frame(generate_ions_for_sequence(peptide_sequence, modifications_df))
```

Identifying matched pairs within criteria

```{r}
setwd(directory)
# scan2012 <- peaks(mz, scan=2012)
# scan2012 <- as.data.frame(scan2012)
# ions_df <- as.data.frame(generate_ions_for_sequence(peptide_sequence, modifications_df))

ppm_tolerance <- 20 # Define your ppm tolerance
matches_with_intensity <- find_matches_with_intensity_df(ions_df, scan2012, ppm_tolerance, peptide_sequence)

# Initialize lists to hold extracted data
ion_type_list <- c()
ion_position_list <- c()
ion_mz_list <- c()
match_mz_list <- c()
match_intensity_list <- c()

# Iterate through matches to extract data
for (match_key in names(matches_with_intensity)) {
  # Split the match_key to extract details
  parts <- strsplit(match_key, "_")[[1]]
  
  # Extract ion type, charge, position, and ion m/z
  ion_type <- parts[1]
  charge_state <- gsub("charge.", "", parts[3])  # Removing "charge." prefix
  ion_position <- as.numeric(parts[5])
  ion_mz <- as.numeric(parts[7])
  
  # Extract matched m/z and intensity from each match
  match_data <- matches_with_intensity[[match_key]]
  for (i in seq_along(match_data$mz)) {
    ion_type_list <- c(ion_type_list, paste(ion_type, "charge", charge_state, sep="_"))
    ion_position_list <- c(ion_position_list, ion_position)
    ion_mz_list <- c(ion_mz_list, ion_mz)
    match_mz_list <- c(match_mz_list, match_data$mz[i])
    match_intensity_list <- c(match_intensity_list, match_data$intensity[i])
  }
}

# Convert lists to dataframe
matches_df <- data.frame(
  ion_type = ion_type_list,
  ion_position = ion_position_list,
  ion_mz = ion_mz_list,
  match_mz = match_mz_list,
  match_intensity = match_intensity_list
)

```

Iterator

```{r}
# Assuming modifications_data, mzR data (for peaks function), and other utilities are loaded

# Initialize a structure to store matches. Here, we use a nested list approach.
matches_data <- list()

# Iterate through modifications_data by scan_number
for (scan_number in names(modifications_data)) {
  matches_data[[scan_number]] <- list()

  # Iterate through hits within each scan_number
  for (hit_rank in names(modifications_data[[scan_number]])) {
    hit_data <- modifications_data[[scan_number]][[hit_rank]]
    sequence <- hit_data$peptide # Assuming this is how you've stored the sequence
    modifications_df <- hit_data$modifications # Assuming modifications are stored in a dataframe

    # Use the scan number to call up m/z and intensity data from mzR
    scan_number_int <- as.integer(scan_number)
    scan_data <- peaks(mz, scan = scan_number_int) # Adjust based on your mzR object name and method
    
    # Generate ions for the sequence with its modifications
    ions_df <- generate_ions_for_sequence(sequence, modifications_df) # Ensure this function can handle modifications_df as intended

    # Find matching ions in the mass spectrometry data
    ppm_tolerance <- 20 # Define your ppm tolerance
    matches_df <- find_matches_with_intensity_df(ions_df, scan_data, ppm_tolerance, sequence)

    # Here, enrich matches_df with peptide sequence and modifications
    matches_df$peptide_sequence <- sequence
    modifications_str <- apply(modifications_df, 1, function(x) paste(x['position'], x['variable'], sep=":"))
    matches_df$modifications <- paste(modifications_str, collapse="; ")

    # Store or append the enriched matches_df data under the correct scan number and hit rank
    matches_data[[scan_number]][[hit_rank]] <- matches_df
  }
}

```

Converting list to data.frame

```{r}
# 1. Prepare Data Chunks
numCores <- detectCores() / 2  # Save one core for system tasks
chunks <- split(matches_data, cut(seq_along(matches_data), breaks = numCores, labels = FALSE))

# 2. Define a Function for Processing Chunks
process_chunk <- function(chunk) {
  # Initialize an empty dataframe for this chunk
  matches_data_df_chunk <- data.frame(
    scan_number = integer(),
    hit_rank = integer(),
    ion_type = character(),
    ion_position = integer(),
    ion_charge = integer(),
    mz = numeric(),
    intensity = numeric(),
    peptide = character(),
    modifications = character(),
    stringsAsFactors = FALSE
  )

  # Loop through each scan_number in the chunk
  for (scan_number in names(chunk)) {
    for (hit_rank in names(chunk[[scan_number]])) {
      hit_data <- chunk[[scan_number]][[hit_rank]]
    
      # Extract peptide_sequence and modifications for this scan_number and hit_rank
      peptide_sequence <- hit_data[["peptide_sequence"]]
      modifications <- hit_data[["modifications"]]
    
      # Ensure ion_keys exclude metadata keys
        ion_keys = setdiff(names(hit_data), c("peptide_sequence", "modifications"))
    
      for (ion_key in ion_keys) { # ion_keys defined by setdiff() excluding metadata keys
        ion_data <- hit_data[[ion_key]]

       # Extract ion_type and ion_position from ion_key
        ion_type <- sub("^(.*?)_ions.*$", "\\1", ion_key) # This might need adjustment
        parts <- strsplit(ion_key, "_pos_")[[1]]
        ion_position <- as.integer(strsplit(parts[2], "_")[[1]][1])

        # Extract ion_charge from ion_key
        charge_pattern <- "_charge[ .]?([0-9]+)_"
        if(length(gregexpr(charge_pattern, ion_key)[[1]]) > 0) { # Ensure a match is found
          matches <- regmatches(ion_key, gregexpr(charge_pattern, ion_key))
          ion_charge <- as.integer(sub(charge_pattern, "\\1", matches[[1]]))
        } else {
          ion_charge <- NA # Assign NA if no charge information is extracted
        }
      
        # Append the new row to matches_data_df_chunk
        matches_data_df_chunk <- rbind(matches_data_df_chunk, data.frame(
          scan_number = as.integer(scan_number),
          hit_rank = as.integer(hit_rank),
          ion_type = ion_type,
          ion_position = ion_position,
          ion_charge = ion_charge,
          mz = ion_data$mz,
          intensity = ion_data$intensity,
          peptide = peptide_sequence,
          modifications = modifications,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  return(matches_data_df_chunk)
}

# 3. Execute in Parallel
cl <- makeCluster(numCores)
on.exit(stopCluster(cl), add = TRUE)

# Assuming 'process_chunk' and necessary libraries are already exported to the cluster
match_results_df_chunks <- parLapply(cl, chunks, process_chunk)

# Combine the dataframes from each chunk
matches_data_df <- do.call(rbind, match_results_df_chunks)

```

Step-wise disambiguation
Step 1: split up modifications data

```{r}
# Assuming matches_data_df_w_mods already exists and has a 'modifications' column

max_mods <- 7

# Adjust the fill_modifications function to work directly on the dataframe
fill_modifications_direct <- function(df, max_mods) {
  for (row in 1:nrow(df)) {
    modification_str <- df$modifications[row]
    if (is.na(modification_str)) next # Skip if NA
    
    mod_parts <- strsplit(modification_str, ";")[[1]]
    mods <- lapply(mod_parts, function(x) strsplit(x, ":")[[1]])
    
    for (i in 1:length(mods)) {
      if (i > max_mods) break # Do not exceed the max number of modifications
      mod_pair <- mods[[i]]
      df[row, paste0("mod_pos_", i)] <- as.numeric(mod_pair[1])
      df[row, paste0("mod_mass_", i)] <- as.numeric(mod_pair[2])
    }
  }
  return(df)
}

# Apply the function to update the dataframe directly
matches_data_df_w_mods <- fill_modifications_direct(matches_data_df, max_mods)

```

Step-wise disambiguation
Step 2: find nearest_before and nearest_after by modification type

```{r}
# HELPER functions

# Modified find_nearest_KR function to operate on dataframe columns
find_nearest_KR_df <- function(peptide, mod_position) {
  # Initialize vectors to store results
  nearest_before <- numeric(length(peptide))
  nearest_after <- numeric(length(peptide))
  
  for (i in seq_along(peptide)) {
    aa_sequence <- unlist(strsplit(peptide[i], ""))
    kr_positions <- which(aa_sequence %in% c("K", "R"))
    nearest_before[i] <- ifelse(any(kr_positions < mod_position[i]), max(kr_positions[kr_positions < mod_position[i]]), NA)
    nearest_after[i] <- ifelse(any(kr_positions > mod_position[i]), min(kr_positions[kr_positions > mod_position[i]]), NA)
  }
  
  # Return a dataframe with the calculated positions
  return(data.frame(nearest_before = nearest_before, nearest_after = nearest_after))
}

# Modified find_nearest_K function to operate on dataframe columns
find_nearest_K_df <- function(peptide, mod_position) {
  # Initialize vectors to store results
  nearest_before <- numeric(length(peptide))
  nearest_after <- numeric(length(peptide))
  
  for (i in seq_along(peptide)) {
    aa_sequence <- unlist(strsplit(peptide[i], ""))
    kr_positions <- which(aa_sequence %in% c("K"))
    nearest_before[i] <- ifelse(any(kr_positions < mod_position[i]), max(kr_positions[kr_positions < mod_position[i]]), NA)
    nearest_after[i] <- ifelse(any(kr_positions > mod_position[i]), min(kr_positions[kr_positions > mod_position[i]]), NA)
  }
  
  # Return a dataframe with the calculated positions
  return(data.frame(nearest_before = nearest_before, nearest_after = nearest_after))
}

# Modified find_nearest_ST function to operate on dataframe columns
find_nearest_ST_df <- function(peptide, mod_position) {
  # Initialize vectors to store results
  nearest_before <- numeric(length(peptide))
  nearest_after <- numeric(length(peptide))
  
  for (i in seq_along(peptide)) {
    aa_sequence <- unlist(strsplit(peptide[i], ""))
    kr_positions <- which(aa_sequence %in% c("S", "T"))
    nearest_before[i] <- ifelse(any(kr_positions < mod_position[i]), max(kr_positions[kr_positions < mod_position[i]]), NA)
    nearest_after[i] <- ifelse(any(kr_positions > mod_position[i]), min(kr_positions[kr_positions > mod_position[i]]), NA)
  }
  
  # Return a dataframe with the calculated positions
  return(data.frame(nearest_before = nearest_before, nearest_after = nearest_after))
}

# Assuming max_mods is already defined as the maximum number of modifications you expect per peptide
# For each modification, you want to add nearest_before_mod_n, nearest_after_mod_n, and nearest_fn

# Add empty columns for nearest_before_mod_n, nearest_after_mod_n, and nearest_fn for each modification
for(i in 1:max_mods) {
  matches_data_df_w_mods[paste0("nearest_before_mod_", i)] <- NA_real_
  matches_data_df_w_mods[paste0("nearest_after_mod_", i)] <- NA_real_
  matches_data_df_w_mods[paste0("nearest_fn_mod_", i)] <- NA_character_
}

# Assuming you have a dataframe `matches_data_df_w_mods` with peptides, modification positions, and masses

# Update the function to directly modify the dataframe
apply_nearest_function_directly <- function(df) {
  # Iterate over each row of the dataframe
  for (i in 1:nrow(df)) {
    # Extract current row's peptide, mod positions, and mod masses
    peptide <- df$peptide[i]
    mod_positions <- sapply(1:max_mods, function(n) df[[paste0("mod_pos_", n)]][i])
    mod_masses <- sapply(1:max_mods, function(n) df[[paste0("mod_mass_", n)]][i])

    # Initialize containers for the results
    nearest_befores <- rep(NA, max_mods)
    nearest_afters <- rep(NA, max_mods)
    nearest_fns <- rep(NA, max_mods)
    
    # Process each modification
    for (j in 1:max_mods) {
      mod_position <- mod_positions[j]
      mod_mass <- mod_masses[j]
      # Skip processing if mod_position or mod_mass is NA
      if (is.na(mod_position) || is.na(mod_mass)) next
      
      # Decide which nearest function to use based on mod_mass
      if (mod_mass %in% c(14.015650, 28.031300, 42.046950)) {
        result <- find_nearest_KR_df(peptide, mod_position)
        nearest_fn <- "KR"
      } else if (mod_mass %in% c(79.966331)) {
        result <- find_nearest_ST_df(peptide, mod_position)
        nearest_fn <- "ST"
      } else if (mod_mass %in% c(42.010565, 56.026215, 86.036779)) {
        result <- find_nearest_K_df(peptide, mod_position)
        nearest_fn <- "K"
      } else {
        result <- list(nearest_before = NA, nearest_after = NA)
        nearest_fn <- "NA"
      }
      
      # Store the results
      nearest_befores[j] <- result$nearest_before
      nearest_afters[j] <- result$nearest_after
      nearest_fns[j] <- nearest_fn
    }

    # Assign the results back to the dataframe
    for (j in 1:max_mods) {
      df[[paste0("nearest_before_mod_", j)]][i] <- nearest_befores[j]
      df[[paste0("nearest_after_mod_", j)]][i] <- nearest_afters[j]
      df[[paste0("nearest_fn_mod_", j)]][i] <- nearest_fns[j]
    }
  }
  
  return(df)
}

# Apply the function to your dataframe
matches_data_df_w_mods_updated <- apply_nearest_function_directly(matches_data_df_w_mods)


```

Step-wise disambiguation
Step 3: use ion identities to determine whether fragments fall between nearest_before and nearest_after

```{r}
# Helper function

#First, we need a function that assembles b_c_ions_df and y_z_ions_df for each scan_number and hit_rank combination from matches_data_df_w_mods_updated. This will involve filtering the dataframe for each ion type and converting y and z ion positions.
 assemble_ions_df <- function(df, target_scan_number, target_hit_rank) {
  b_c_ions_df <- df %>% 
    filter(scan_number == as.numeric(target_scan_number), hit_rank == as.numeric(target_hit_rank), ion_type %in% c("b", "c", "b_nl_O", "c_nl_O", "b_nl_N", "c_nl_N"))
  
  y_z_ions_df <- df %>%
    filter(scan_number == as.numeric(target_scan_number), hit_rank == as.numeric(target_hit_rank), ion_type %in% c("y", "z", "y_nl_O", "y_nl_O", "z_nl_N", "z_nl_N")) %>%
    mutate(ion_position = nchar(peptide) - ion_position + 1)

  # Debugging print statements
  print(paste("BC Ions DF Rows:", nrow(b_c_ions_df)))
  print(paste("YZ Ions DF Rows:", nrow(y_z_ions_df)))
  
  return(list(b_c_ions_df = b_c_ions_df, y_z_ions_df = y_z_ions_df))
}

# ions_result <- assemble_ions_df(matches_data_df_w_mods_updated, "2012", "1")

check_unambiguity_before <- function(nearest_before, mod_position, b_c_ions_df, y_z_ions_df) {
  # If nearest_before is NA, return unambiguous
  if (is.na(nearest_before)) return(TRUE)

  bc_unambiguous <- any(b_c_ions_df$ion_position >= nearest_before & b_c_ions_df$ion_position < mod_position)
  yz_unambiguous <- any(y_z_ions_df$ion_position > nearest_before & y_z_ions_df$ion_position <= mod_position)
  return(bc_unambiguous || yz_unambiguous)
  # TRUE || NA will return TRUE, because if one operand is TRUE, the overall expression is TRUE regardless of the other operand
  # TRUE || FALSE will return TRUE, because if one operand is TRUE, the overall expression is TRUE regardless of the other operand
  # NA || TRUE will also return TRUE for the same reason
  # FALSE || NA will return NA, because the outcome depends on the unknown (NA) operand
  # NA || FALSE will return NA as well, for the same reason as above
  # NA || NA will return NA, because there's no sufficient information to determine the result
}

check_unambiguity_after <- function(nearest_after, mod_position, b_c_ions_df, y_z_ions_df) {
  # If nearest_after is NA, return unambiguous
  if (is.na(nearest_after)) return(TRUE)

  bc_unambiguous <- any(b_c_ions_df$ion_position < nearest_after & b_c_ions_df$ion_position >= mod_position)
  yz_unambiguous <- any(y_z_ions_df$ion_position <= nearest_after & y_z_ions_df$ion_position > mod_position)
  return(bc_unambiguous || yz_unambiguous)
}

# Add the required columns for ambiguity checks
matches_data_df_w_mods_updated <- matches_data_df_w_mods_updated %>%
  mutate(across(paste0("mod_pos_", 1:max_mods), 
                list(bc_before_unambiguous = ~NA,
                     yz_before_unambiguous = ~NA,
                     bc_after_unambiguous = ~NA,
                     yz_after_unambiguous = ~NA),
                .names = "{.col}_{.fn}"))

# Working function to apply ambiguity checks for each modification in a row
  apply_ambiguity_checks <- function(df, max_mods) {
  # Iterate through each mod_pos_ column
  for (i in 1:max_mods) {
    mod_pos_col <- paste0("mod_pos_", i)
    nearest_before_col <- paste0("nearest_before_mod_", i)
    nearest_after_col <- paste0("nearest_after_mod_", i)
    bc_before_unambiguous_col <- paste0("mod_pos_", i, "_bc_before_unambiguous")
    yz_before_unambiguous_col <- paste0("mod_pos_", i, "_yz_before_unambiguous")
    bc_after_unambiguous_col <- paste0("mod_pos_", i, "_bc_after_unambiguous")
    yz_after_unambiguous_col <- paste0("mod_pos_", i, "_yz_after_unambiguous")
    
    # Dynamically creating column names for assignment
    df <- df %>%
      rowwise() %>%
      mutate(
        !!bc_before_unambiguous_col := if_else(
          !is.na(.data[[mod_pos_col]]),
          # Assuming assemble_ions_df and check_unambiguity_before return a single value or NA_real_
          {
            ions <- assemble_ions_df(cur_data(), scan_number, hit_rank)
            check_unambiguity_before(.data[[nearest_before_col]], .data[[mod_pos_col]], ions$b_c_ions_df, ions$y_z_ions_df)
          },
          NA_real_
        ),
        !!yz_before_unambiguous_col := if_else(
          !is.na(.data[[mod_pos_col]]),
          {
            ions <- assemble_ions_df(cur_data(), scan_number, hit_rank)
            check_unambiguity_before(.data[[nearest_before_col]], .data[[mod_pos_col]], ions$b_c_ions_df, ions$y_z_ions_df)
          },
          NA_real_
        ),
        !!bc_after_unambiguous_col := if_else(
          !is.na(.data[[mod_pos_col]]),
          {
            ions <- assemble_ions_df(cur_data(), scan_number, hit_rank)
            check_unambiguity_after(.data[[nearest_after_col]], .data[[mod_pos_col]], ions$b_c_ions_df, ions$y_z_ions_df)
          },
          NA_real_
        ),
        !!yz_after_unambiguous_col := if_else(
          !is.na(.data[[mod_pos_col]]),
          {
            ions <- assemble_ions_df(cur_data(), scan_number, hit_rank)
            check_unambiguity_after(.data[[nearest_after_col]], .data[[mod_pos_col]], ions$b_c_ions_df, ions$y_z_ions_df)
          },
          NA_real_
        )
      ) %>%
      ungroup()
  }
  return(df)
}


# Make sure to pass the actual number of max_mods you have in your data
test_df <- apply_ambiguity_checks(df, max_mods)


# Apply the checks
# matches_data_df_w_mods_updated <- apply_ambiguity_checks(matches_data_df_w_mods_updated)

# write_excel_csv(matches_data_df_w_mods_updated, "matches_data_df_w_mods_updated_ambiguity_check1")

```

Parallelization

```{r}
library(parallel)
library(dplyr)
library(tidyr)
library(stringr)

detectCores()

# Step 1: Group your dataframe by scan_number
grouped_df_list <- matches_data_df_w_mods_updated %>% 
  group_by(scan_number) %>%
  group_split()

# Step 2: Prepare to use parallel processing
numCores <- detectCores() / 2  # Reserve one core for system tasks
cl <- makeCluster(numCores)
on.exit(stopCluster(cl), add = TRUE)

# Step 3: Export necessary objects and functions to each cluster node
clusterExport(cl, varlist = c("apply_ambiguity_checks", "max_mods", "assemble_ions_df", "check_unambiguity_before", "check_unambiguity_after"))
clusterEvalQ(cl, {
  library(dplyr)  # Assuming dplyr is used in your functions
  library(purrr)
  library(tidyr)
  library(stringr)
})

# Execute the task in parallel
results <- parLapply(cl, grouped_df_list, function(group) {
  apply_ambiguity_checks(group, max_mods)
})

# Combine the results from all cores
# The method to combine results depends on the structure of your output
combined_results_2 <- bind_rows(results)

save(combined_results_2,file = "combined_results_2.RData")

library(readr)
setwd(directory)
write_excel_csv(combined_results_2, "combined_results_2.csv")
```

Confirm whether a hit has disambiguiating ions between all modification sites

```{r}
library(dplyr)
library(purrr)

# Simplified check_columns function
disambiguate <- function(data, col_range_start, col_range_end) {
  # Assuming data is already filtered for a specific scan_number and hit_rank
  
  # Dynamically select the range of columns if col_range_start and col_range_end are column names
  columns_to_check <- select(data, dplyr::all_of(col_range_start):dplyr::all_of(col_range_end))
  
  # Apply the check across the specified columns
  columns_check_result <- purrr::map_lgl(columns_to_check, function(column) {
    # Check if the column contains at least one "1"
    has_one <- any(column == 1, na.rm = TRUE)
    # If the column has at least one "1", it satisfies the condition
    if (has_one) {
      return(TRUE)
    } else {
      # If there are no "1"s, check if there's at least one NA (which also satisfies the condition)
      return(all(is.na(column)))
    }
  })
  
  # Return TRUE if all columns meet the criteria
  return(all(columns_check_result))
}

# Function to iterate over all scan_number and hit_rank combinations and apply check_columns
disambiguate_all <- function(data, col_range_start, col_range_end) {
  results <- data %>%
    group_by(scan_number, hit_rank) %>%
    summarise(all_true = disambiguate(cur_data(), col_range_start, col_range_end), .groups = 'drop')
  
  return(results)
}

# Step 1: Group your dataframe by scan_number
grouped_df_list <- combined_results_2 %>% 
  group_by(scan_number) %>%
  group_split()

# Step 2: Prepare to use parallel processing
numCores <- detectCores() / 2  # Reserve one core for system tasks
cl <- makeCluster(numCores)
on.exit(stopCluster(cl), add = TRUE)

# Step 3: Export necessary objects and functions to each cluster node
clusterExport(cl, varlist = c("disambiguate", "disambiguate_all"))
clusterEvalQ(cl, {
  library(dplyr)  # Assuming dplyr is used in your functions
  library(purrr)
  library(tidyr)
  library(stringr)
})

# Execute the task in parallel
results <- parLapply(cl, grouped_df_list, function(group) {
  disambiguate_all(group, 'mod_pos_1_bc_before_unambiguous', 'mod_pos_7_yz_after_unambiguous')
})

# Combine the results from all cores
# The method to combine results depends on the structure of your output
disambiguated_results <- bind_rows(results)

active_results_df <- disambiguate_all(combined_results_2, 'mod_pos_1_bc_before_unambiguous', 'mod_pos_7_yz_after_unambiguous')
```

Debugging

```{r}
setwd(directory)
library(dplyr)

subset_df <- matches_data_df_w_mods_updated %>%
  filter(scan_number == 6777)

subset_df <- apply_ambiguity_checks(subset_df)

print(assemble_ions_df(subset_df, "6777", "1"))
```

